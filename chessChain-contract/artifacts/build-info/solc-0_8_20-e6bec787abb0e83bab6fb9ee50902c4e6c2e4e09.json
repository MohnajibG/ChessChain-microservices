{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_20-e6bec787abb0e83bab6fb9ee50902c4e6c2e4e09",
  "solcVersion": "0.8.20",
  "solcLongVersion": "0.8.20+commit.a1b79de6",
  "userSourceNameMap": {
    "contracts/CheckChain.sol": "project/contracts/CheckChain.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "shanghai",
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/CheckChain.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\n/**\n * @title CheckChain\n * @dev Contrat pour gérer des parties avec mise (stake) fixe : 10, 25 ou 50 tokens ERC20 (ex: USDC).\n */\ninterface IERC20 {\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n    function transfer(address to, uint256 value) external returns (bool);\n}\n\ncontract CheckChain {\n    IERC20 public immutable token;\n\n    enum GameStatus { Waiting, Ready, Finished }\n\n    struct Game {\n        address player1;\n        address player2;\n        uint256 stake;\n        GameStatus status;\n    }\n\n    uint256 public gameCount;\n    mapping(uint256 => Game) public games;\n\n    event GameCreated(uint256 indexed gameId, address indexed player1, uint256 stake);\n    event GameJoined(uint256 indexed gameId, address indexed player2);\n    event GameFinished(uint256 indexed gameId, address winner);\n\n    constructor(address tokenAddress) {\n        token = IERC20(tokenAddress);\n    }\n\n    /// @notice Créer une nouvelle partie avec un stake fixe (10, 25, 50)\n    function createGame(uint256 stake) external returns (uint256) {\n        require(stake == 10 || stake == 25 || stake == 50, \"Stake not allowed\");\n\n        // Transfert des tokens du joueur1 vers le contrat\n        require(token.transferFrom(msg.sender, address(this), stake), \"Token transfer failed\");\n\n        gameCount++;\n        games[gameCount] = Game({\n            player1: msg.sender,\n            player2: address(0),\n            stake: stake,\n            status: GameStatus.Waiting\n        });\n\n        emit GameCreated(gameCount, msg.sender, stake);\n        return gameCount;\n    }\n\n    /// @notice Rejoindre une partie existante\n    function joinGame(uint256 gameId) external {\n        Game storage game = games[gameId];\n        require(game.status == GameStatus.Waiting, \"Game not available\");\n        require(game.player1 != msg.sender, \"Cannot join your own game\");\n\n        // Transfert des tokens du joueur2 vers le contrat\n        require(token.transferFrom(msg.sender, address(this), game.stake), \"Token transfer failed\");\n\n        game.player2 = msg.sender;\n        game.status = GameStatus.Ready;\n\n        emit GameJoined(gameId, msg.sender);\n    }\n\n    /// @notice Terminer la partie et désigner un gagnant\n    function finishGame(uint256 gameId, address winner) external {\n        Game storage game = games[gameId];\n        require(game.status == GameStatus.Ready, \"Game not ready\");\n        require(winner == game.player1 || winner == game.player2, \"Invalid winner\");\n\n        // Transfert de la cagnotte au gagnant\n        uint256 prize = game.stake * 2;\n        require(token.transfer(winner, prize), \"Payout failed\");\n\n        game.status = GameStatus.Finished;\n\n        emit GameFinished(gameId, winner);\n    }\n}\n"
      }
    }
  }
}